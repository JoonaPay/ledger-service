#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = require("commander");
const chalk_1 = __importDefault(require("chalk"));
const generate_module_1 = require("./commands/generate-module");
const generate_entity_1 = require("./commands/generate-entity");
const generate_usecase_1 = require("./commands/generate-usecase");
const generate_all_1 = require("./commands/generate-all");
const program = new commander_1.Command();
program
    .name('ddd')
    .description('CLI for generating NestJS DDD boilerplate code')
    .version('1.0.0');
program
    .command('generate <type> <name>')
    .alias('g')
    .description('Generate boilerplate code')
    .option('-m, --module <module>', 'Module name')
    .option('-p, --path <path>', 'Base path for generation', process.cwd())
    .option('--skip-orm', 'Skip ORM entity generation')
    .option('--skip-mapper', 'Skip mapper generation')
    .option('--skip-repo', 'Skip repository generation')
    .option('--with-events', 'Include domain events')
    .option('--with-queries', 'Include query handlers')
    .action(async (type, name, options) => {
    try {
        switch (type.toLowerCase()) {
            case 'module':
                await (0, generate_module_1.generateModule)(name, options);
                break;
            case 'entity':
                await (0, generate_entity_1.generateEntity)(name, options);
                break;
            case 'usecase':
            case 'use-case':
                await (0, generate_usecase_1.generateUseCase)(name, options);
                break;
            case 'all':
                await (0, generate_all_1.generateAll)(name, options);
                break;
            default:
                console.error(chalk_1.default.red(`Unknown type: ${type}`));
                console.log(chalk_1.default.yellow('Available types: module, entity, usecase, all'));
                process.exit(1);
        }
    }
    catch (error) {
        console.error(chalk_1.default.red('Error:'), error.message);
        process.exit(1);
    }
});
program
    .command('scaffold <entityName>')
    .alias('s')
    .description('Generate complete CRUD scaffolding for an entity')
    .option('-m, --module <module>', 'Module name (will be created if not exists)')
    .option('-p, --path <path>', 'Base path for generation', process.cwd())
    .action(async (entityName, options) => {
    try {
        await (0, generate_all_1.generateAll)(entityName, { ...options, complete: true });
    }
    catch (error) {
        console.error(chalk_1.default.red('Error:'), error.message);
        process.exit(1);
    }
});
program.parse();
//# sourceMappingURL=index-old.js.map